<html>
  <head>
    {init}
    {config}
    {loader}
  </head>
  <body>
    <script>
      console.debug('0123456789', 12.345, { a: 1, b: 2 });
      console.error('0123456789', 12.345, { a: 1, b: 2 });
      console.info('0123456789', 12.345, { a: 1, b: 2 });
      console.log('0123456789', 12.345, { a: 1, b: 2 });
      console.trace('0123456789', 12.345, { a: 1, b: 2 });
      console.warn('0123456789', 12.345, { a: 1, b: 2 });
      console.debug(function () { return true }, new Error('error message'));
      console.error(function () { return true }, new Error('error message'));
      console.info(function () { return true }, new Error('error message'));
      console.log(function () { return true }, new Error('error message'));
      console.trace(function () { return true }, new Error('error message'));
      console.warn(function () { return true }, new Error('error message'));

      /**
       * Efficiently generates a string of specified length (even very large strings).
       *
       * @param {number} size - The length of the string to generate.
       * @return {string} The generated string.
       */
      function makeString(size) {
        var str = ''

        // Build up the size by repeatedly doubling a base string; then start over with whatever is left from the
        // last doubling that doesn't exceed the remaining length; and repeat until the remaining string is smaller
        // than or equal to the base string.
        var base = '0123456789'
        var remainingSize = size
        while (remainingSize > base.length) {
          var iterations = 0
          var moreString = '0123456789'
          while (10 * Math.pow(2, iterations + 1) < remainingSize) {
            moreString += moreString
            iterations++
          }
          str += moreString
          remainingSize -= 10 * Math.pow(2, iterations)
        }
        // Once we've efficiently built the string as large as we can, finish with a simple iteration on the remainder.
        for (var i = str.length; i < size; i++) {
          str += i % 10
        }
        return str
      }

      /**
       * Generates a nested object that will yield a string of the specified size when stringified. The algorithm attempts to
       * achieve symmetrical breadth (properties per layer), depth (layers of nesting), and distribution of string values.
       *
       * @param {integer} targetSize - The desired string length of the object when stringified.
       * @returns {Object} An object of the specified size, or null if targetSize is 0.
       */
      function generateObject (targetSize) {
        if (typeof targetSize === 'undefined') targetSize = 100; // IE
        // The algorithm misbehaves on some values smaller than 100.
        if (targetSize < 100) {
          if (targetSize === 0) return null;
          if (targetSize === 1) return 0;
          return makeString(targetSize - 2); // string + ""
        }

        // Start with reasonably symmetrical targets.
        var targetValueLength = Math.floor(Math.sqrt(targetSize));
        var targetTerminalNodeCount = targetSize / targetValueLength;

        // Calculate a roughly symmetrical breadth and depth.
        var b = 1; // properties per layer
        var d = 1; // number of nested layers
        while (Math.pow(b, d) < targetTerminalNodeCount) {
          b++;
          if (Math.pow(b, d) > targetTerminalNodeCount) { b--; break; }
          if (Math.pow(b, d) < targetTerminalNodeCount) d++;
          if (Math.pow(b, d) > targetTerminalNodeCount) { d--; b++; }
          if (Math.pow(b, d) > targetTerminalNodeCount) { b--; break; }
        }

        // Estimate the eventual JSON overhead to know how much to reduce the length of the values.
        var jsonOverheadPerLayer = 2 + b * 4 + (b > 1 ? b - 1 : 0); // {} + keys + commas
        var totalJsonOverhead = 0;
        for (var l = 0; l < d; l++) {
          totalJsonOverhead += Math.pow(b, l) * jsonOverheadPerLayer;
        }
        totalJsonOverhead += Math.pow(b, d) * 2 // "" per value in deepest nest
        var sizeMinusOverhead = targetSize - totalJsonOverhead

        // Adjust the target value length to fill up as much remaining size as can be done symmetrically.
        var terminalNodeCount = Math.pow(b, d); //
        targetValueLength = Math.floor(sizeMinusOverhead / terminalNodeCount); //
        var remainder = sizeMinusOverhead - targetValueLength * terminalNodeCount; // to be distributed evenly

        // Build nested objects recursively until terminal depth is reached, then apply string values.
        var value = makeString(targetValueLength);
        function createLayer(breadth, depth) {
          var obj = {};
          for (let i = 0; i < breadth; i++) {
            var key = i;
            if (depth > 1) {
              obj[key] = createLayer(breadth, depth - 1);
            } else {
              obj[key] = value;
              if (remainder > 0) { // distribute evenly
                obj[key] += '0';
                remainder--;
              }
            }
          }
          return obj;
        }

        return createLayer(b, d);
      }
    </script>
  </body>
</html>
